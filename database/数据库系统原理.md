[toc]



## 一、事务

### 概念

事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。

### ACID

#### 1. 原子性（Atomcity）

事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。

回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

#### 2. 一致性（Consistency）

数据库在事务执行前后都保持一致性状态。在一致性状态下，**所有事务对同一个数据的读取结果都是相同的。**

#### 3. 隔离性（Isolation）

一个事务所做的修改在最终提交前，对其他事务是不可见的。

#### 4. 持久性（Durability）

一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。

系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。

#### Autocommit

MySQL 默认采用自动提交模式。也就是说，如果不显式使用`START TRANSACTION`语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。



## 二. 并发一致性问题

在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。

### 丢失修改

丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。

### 脏读

读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。

### 不可重复读

不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。

### 幻读

幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。

## 三.锁

![image-20210104130528627](https://gitee.com/Vanni/pic-bed/raw/master/img/image-20210104130528627.png)

锁的大类可以分为乐观锁与悲观锁

- 悲观锁：对数据处理持悲观态度，总认为冲突会发生，获取和修改数据时，数据会被别人修改
- 乐观锁：对数据处理持乐观态度，认为数据一般情况下不会发生冲突，所有修改都有效

### 封锁粒度

Mysql中提供了三种封锁粒度：表级锁，页级锁，行级锁。

应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。

但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。

在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。

### 锁类型

#### 读写锁

- 互斥锁（Exclusive）：简称写锁，X锁
- 共享锁（Shared）： 简称读锁，S锁
- 更新锁（Updated）

有以下两个规定：

- 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。
- 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。

![image-20210104160309954](https://gitee.com/Vanni/pic-bed/raw/master/img/image-20210104160309954.png)



【注意】在文中所有的读操作，指的都是“当前读”，快照读是不需要加锁的

#### **意向锁**

使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。

在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。

为了解决这个问题，引入了意向锁，意向锁也分为意向读/写锁，**均为表级锁**， 用来表示一个事务想要在**对某个数据添加行锁**

有以下两个规定：

- 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；
- 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。

![image-20210104160342977](https://gitee.com/Vanni/pic-bed/raw/master/img/image-20210104160342977.png)

### **封锁协议**

### 三级封锁协议

1. 一级封锁

   事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。

   可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。

2. 二级封锁

   在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。

   可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。

3. 三级封锁

   在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。

   可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。

### 两段锁协议

**加锁和解锁分为两个阶段进行。**

可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。

事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。

```
lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)
```

但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。

```
lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)
```



### Mysql隐式和显式锁定

MySQL 的 InnoDB 存储引擎采用两段锁协议，会**根据隔离级别在需要的时候自动加锁**，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。

InnoDB 也可以使用特定的语句进行显示锁定：

```
SELECT ... LOCK In SHARE MODE;
SELECT ... FOR UPDATE;
```



## 隔离级别

### 未提交读（READ UNCOMMITTED）

事务中的修改，即使没有提交，对其它事务也是可见的。

### 提交读（READ COMMITTED）

一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。

这个隔离级别会出现【不可重复读】、【幻读】

### 可重复读（REPEATABLE READ）

保证在同一个事务中多次读取同一数据的结果是一样的。

这个隔离级别解决了【不可重复读】，但是仍会有【幻读】

### 可串行化（SERIALIZABLE）

强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。

该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。

## 版本并发控制（MVCC）

多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现



### 基本思想

在**封锁**一节中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。

在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。

脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，**MVCC 规定只能读取已经提交的快照**。当然一个事务可以读取自身未提交的快照，这不算是脏读。



在MVCC中，读操作分为两种：快照度和当前读。

- 快照读：读取的是记录的可见版本。（有可能是历史版本），不用加锁。
- 当前读：读取的是记录的最新版本，并且当前读返回的记录，都会加上锁，保证其他事务不会并发修改这条记录。

### 版本号

- 系统版本号 SYS_ID： 是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增
- 事务版本号 TRX_ID： 事务开始时的系统版本号

### 版本链

对InnoDB存储引擎表来说，聚簇索引记录中都包含两个必要的隐藏列信息（row_id并不是必要的）

![image-20210105002537823](https://gitee.com/Vanni/pic-bed/raw/master/img/image-20210105002537823.png)

每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个roll_pointer属性（INSERT操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些undo日志都连起来，串成一个链表，所以现在的情况就像下图一样：

![image-20210105002723708](https://gitee.com/Vanni/pic-bed/raw/master/img/image-20210105002723708.png)

对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一个链表，**我们把这个链表称之为版本链**，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务id。

### **Readview**

ReadView就是一个保存事务的list，记录的是本事务执行时，Mysql当前还有哪些事务在执行

包含以下四个重要的内容

- m_ids: 表示在生成此ReadView时系统活跃的读写事务的事务id列表
- min_trx_id: 表示在生成此ReadView时当前系统中活跃事务中最小的事务ID，即m_ids中的最小值
- max_trx_id: 表示生成ReadView时系统中应该分配给下一个事务的id值
- creator_trx_id: 表示生成该ReadView时的事务的ID

【注意】

​	max_trx_id并不是m_ids中的最大值，事务ID是全局递增的，比如说现在有1,2,3三个事务，之后id为3的事务提交了，那么新的一个读事务在生成ReadViews时，m_ids就包括1和2，min_trx_id就是1， max_trx_id就是4了



![image-20210106160746653](https://gitee.com/Vanni/pic-bed/raw/master/img/image-20210106160746653.png)



1、 看到当前事务ID为600，596以下的事务已经提交且可以看到

2、 事务ID为601及以上的，这个事务不应该看到

3、 当前活跃的事务应该为{596,597,598,599}的子集



那么根据ReadView，哪些数据是可读的呢

 

根据InnoDB的行格式，在聚集索引记中记录有隐藏的列信息【trx_id】,即对该行数据进行修改的最新的事务ID

假设活跃的事务为{596, 598}，假设当前事务隔离方式是可重复读——repeatable read

 

a. 如果行数据的修改事务ID小于596，由于在事务启动的时候，596之前的所有线程都已经提交了，那么该行数据可读

b. 如果行数据的修改事务ID大于601，那么该行数据肯定不可读，而对自己（即事务ID为600），本事务未提交，也无法通过select读出数据

c. 如果行数据的修改事务ID在readView里面，trx_id在{596, 598}中，说明该行数据在当前事务（600）开始时，没有提交修改，为了保证事务内任何时间读取到的数据都是一致的，需要根据undo log进行数据的回溯，每次回溯都要进行【数据是否可读的判断】，即执行a、b、c、d步骤，直到找到一个可读的数据

d. 如果行数据的修改事务ID不在readView中，trx_id在{597、599}中，说明修改行数据是在本事务（600）开始前已经提交，刚行数据可读



![image-20210106192410083](https://gitee.com/Vanni/pic-bed/raw/master/img/image-20210106192410083.png)



#### 使用ReadView和版本链实现多种隔离级别

![image-20210106221103666](https://gitee.com/Vanni/pic-bed/raw/master/img/image-20210106221103666.png)

​	有了ReadView之后，在访问某条记录时，只需要按照以下步骤来判断记录的某个版本是否可见：

- 如果被访问的版本的trx_id属性与ReadView中的creator_trx_id值相同，则表明当前事务在访问它自己修改过的记录，该版本可以被当前事务访问
- 若被访问的版本的trx_id属性值比ReadView中的min_trx_id值小，**则表明生成该版本的事务在当前事务生成该Readview前已经提交**（注意不是 当前版本已在当前事务前已经提交，一个事务可以生成多个ReadView），所以该版本可见
- 若被访问的版本的trx_id属性值比大于ReadView中的max_trx_id，**表明生成该版本的事务是在当前事务生成该ReadView后才开始的**， 所以该版本不可见
- 若被访问的版本的trx_id属性值在ReadView的min_trx_id和max_trx_id之间（包含边界），则需要判断该trx_id是否在当前ReadView的m_ids里，如果在，说明创建ReadView时生成该版本的事务还在活跃，所以当前版本不可见；若不在，说明创建ReadView时创建该版本的事务已经提交，该版本可见。

![image-20210106230402045](https://gitee.com/Vanni/pic-bed/raw/master/img/image-20210106230402045.png)

**当然，触发生成ReadView的读操作都是【当前读】**

## InnoDb的锁

MVCC并不能解决幻读问题，而Mysql中的InnoDB是使用了**Next-Key-Lock**来解决这个问题。在Repeatable Read隔离级别中，使用MVCC+Next-Key-Lock来解决幻读问题

### Record Lock

字面意思为行锁，即锁定表中某条具体的记录，但是**锁是直接加在索引上面的**，若表中没有设置索引，InnoDb会自动在主键上创建隐藏的聚簇索引。

### Gap Lock

锁定索引之间的间隙，但不包括索引本身。

### Next-Key-Lock

行锁 + Gap Lock，锁定一个前开后闭的空间，若索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：

![image-20210110222609233](https://gitee.com/Vanni/pic-bed/raw/master/img/image-20210110222609233.png)