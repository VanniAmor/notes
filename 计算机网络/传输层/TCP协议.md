## TCP数据包格式说明

![img](https://near.qfpay.com.cn/op_upload/483425/1536566026908.jpeg)

TCP数据段分为**首部+数据**两部分。
首部又分为固定首部和可选项首部。



- 来源连接端口（16比特位）-辨识发送连接端口

- 目的连接端口（16比特位）-辨识接收连接端口

- 序列号（seq，32比特位）-TCP数据包标识。

  - 无惧传输时的乱序或丢包
  - 建立连接时发送和接收方第一次数据段的seq均为随机生成（TCP序号预测攻击），之后是上次序列号加1
  - 发送数据时seq为上一次发送的数据长度加1，如果数据长度为0则seq不变

- 确认号（ack，32比特位）-表示接收方期望下次收到的数据包的序列号的值，也是当前收到的数据的字节长度加1

- 数据偏移（4比特位）-以4字节为单位计算出的数据段开始地址的偏移值，例1111 -> 15 -> 60字节

- 保留位（3比特位）-需置为0

- 标志符（9比特位）

  - NS：Nonce Sum 随机和，
  - CWR：Congestion Window Reduced 拥塞窗口减少标志被发送主机设置，用来表明它接收到了设置ECE标志的TCP包。拥塞窗口是被TCP维护的一个内部变量，用来管理发送窗口大小
  - ECE：ECN-Echo(显式拥塞通知回显) ECN响应标志被用来在TCP3次握手时表明一个TCP端是具备ECN功能的，并且表明接收到的TCP包的IP头部的ECN被设置为11 NS/CWR/ECE三个标志组合实现估计网络拥塞情况的功能
  - URG：为1表示高优先级数据包，紧急指针字段有效
  - ACK：为1表示确认号字段有效
  - PSH：为1表示是带有PUSH标志的数据，指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满
  - RST：为1表示出现严重差错，可能需要重新创建TCP连接，还可以用于拒绝分发的报文段和拒绝连接请求
  - SYN：为1表示这是连接请求或是连接接受请求，用于创建连接和使顺序号同步
  - FIN：为1表示发送方没有数据要传输了，要求释放连接

- 窗口（WIN 16比特位）-表示从确认号开始，本报文的接收方可以接收的字节数，即接收窗口大小，用于流量控制

- 校验和（Checksum 16比特位） -对整个TCP报文段，包括TCP首部和TCP数据，计算出来的16位值，这是一个强制字段。校验方式为：将TCP报文段的头部和数据部分的和计算出来，再对其求反码

- 紧急指针（16比特位）-本报文段中的紧急数据的最后一个字节的序号

- 选项字段 -最多40字节，每个选项的开始是1字节的kind字段，说明选项的类型。下面具体说明支持的选项字段类型

  ​	0：（1字节）选项表结束
  ​	1：无操作（1字节）用于选项字段之间的字节边界对齐和分割不同的选项数据

  ​	2：最大报文长度（4字节，Maximum segment size，MSS） -在握手阶段告知接收方，发送方支持的最大报文数据段的长度，以太网一般为1460。只能出现在同步报文段中，否则将被忽略。通常将MSS设置为MTU-40字节（Maximum Transmission Unit 最大传输单元），这样携带TCP报文段的IP数据报的长度就不会超过MTU，从而避免本机发生IP分片。
  ​	3：窗口扩大因子（3字节，wscale）-取值0-14，用来把TCP的窗口的值左移的位数。只能出现在同步报文中，否则将被忽略。这是因为现在的TCP接收数据缓冲区（接收窗口）的长度通常大于65535字节
  ​	4：sackOK -发送端支持并同意使用SACK（Selective Acknowledgements，选择确认）选项
  ​	5：SACK实际工作的选项，存放丢包的边界信息，最多存放4个包的边界信息。例如123，丢了2，那么SACK存放的就是2号包的开始和结束的字节序列号
  ​	8：时间戳（10字节，TCP Timestamps Option，TSopt）
  ​			发送端的时间戳（Timestamp Value field， TSval，4字节）
  ​			时间戳回显应答（Timestamp Echo Reply field，TSecr，4字节）
  ​			时间戳的功能有两个：
  ​				用来计算往返时间RTT（Round-Trip Time），发送方在收到确认报文后，可以准确计算出RTT。
  ​				防止回绕的序列号，通过时间戳可以判断出相同序列号的数据报，哪个是最近发送的，哪个是以前发送的。

  ​	

## TCP三次握手

![image-20210313205406218](https://gitee.com/Vanni/pic-bed/raw/master/img/image-20210313205406218.png)



第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。

第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。



### 为何不用二次握手



当为两次握手的时候，假设客户端A向服务端B发起连接，此时A的第一次请求在网络中延迟了，然后A第二次发起请求，B收到A第二次的请求，并响应确定，此时AB建立了连接并进行数据传输。当数据传输后断开连接，A的第一次请求到达了B，B以为A又再次发起请求，进而发出响应确定，AB建立了连接，且B一直等待A的数据，但是对A来讲，并没有建立连接，不会对B传输数据。



## 四次挥手



由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。



1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。

  （2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。

 （3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。

  （4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。


## TCP与UDP的区别

1. TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
2. TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付
3. TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文的
4. UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
5. 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
6. TCP首部开销20字节;UDP的首部开销小，只有8个字节
7. TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道



## 流量控制

TCP 提供了流量控制服务以消除发送方使接收方缓存区溢出的可能性，因此 **TCP 流量控制是为了匹配发送方的发送速率与接收方的读取速率**。

TCP中使用滑动窗口机制来实现流量控制

![image-20210313183911206](https://gitee.com/Vanni/pic-bed/raw/master/img/image-20210313183911206.png)



## 拥塞控制



**拥塞控制是让网络能够承受现有的网络负荷，它是一个全局性的过程，涉及所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。**而流量控制往往是指点对点通信量的控制，即接收端控制发送端，它所做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。

- 慢开始

- 拥塞避免

- 快重传

- 快恢复




![image-20210313183735190](https://gitee.com/Vanni/pic-bed/raw/master/img/image-20210313183735190.png)



### 快重传

所谓快重传，即当Sender收到三个重复的ack，就确认有包丢失，进而把丢失的包重新发送

![å¨è¿éæå¥å¾çæè¿°](https://img-blog.csdnimg.cn/20190731184314574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDMxNDA2,size_16,color_FFFFFF,t_70)

所做的事情有

- 把ssthresh设置为cwnd的一半
- 把cwnd再设置为ssthresh的值(具体实现有些为ssthresh+3)
- 重新进入拥塞避免阶段。



### 快恢复

前后有比较多的版本，比较出名的有Tahoe、Reno、NewReno



有三个TCP版本

- Tahoe，此为最旧，此时的快恢复算法是在发生超时重传的时候，直接将cwnd设置为1，然后进行慢开始算法
- Reno，改良版，此时的快恢复算法是在发生超时重传或收到第三个重复确认（快重传）的时候， ssthresh 的值设置为 cwnd 值的一半，同时 cwnd = ssthresh （在有些版本中，会让 cwnd = ssthresh + 3）。

- NewReno，Reno改良版， 在Reno的基础上稍微改动，NewReno需要在收到一个窗口内所有数据包的确认后才会退出快恢复的状态

![img](https://img-blog.csdn.net/20160923215836261?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

可以看出Reno的快速重传算法是针对一个包的重传情况的，然而在实际中，一个重传超时可能导致许多的数据包的重传，因此当多个数据包从一个数据窗口中丢失时并且触发快速重传和快速恢复算法时，问题就产生了。



因此NewReno出现了，它在Reno快速恢复的基础上稍加了修改，可以恢复一个窗口内多个包丢失的情况。具体来讲就是：Reno在收到一个新的数据的ACK时就退出了快速恢复状态了，而NewReno需要收到该窗口内所有数据包的确认后才会退出快速恢复状态，从而更一步提高吞吐量。



## 参考文献



https://www.cnblogs.com/never--more/p/7193628.html
