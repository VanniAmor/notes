## 概述

TCP是面向连接的可靠传输协议，是以流作为传输方式的

所谓流，是指字节流，是指流入到进程或从进程流出的字节序列。

虽然应用程序和TCP的交互是一次一个数据块，但TCP把应用程序交下来的数据看成是一连串无结构的字节流。



所谓可靠，即保证通信过程中消息的**完整，正确，有序**



## 滑动窗口与连续ARQ协议

通过ARQ和滑动窗口来保证数据的正确性



### ARQ协议

ARQ协议，即自动重传请求（Automatic Repeat-Request），若果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括**停止等待ARQ协议和连续ARQ协议**，拥有错误检测（Error Detection）、正面确认（Positive Acknowledgment）、超时重传（Retransmission after Timeout）和 负面确认及重传（Negative Acknowledgment and Retransmission）等机制。


### 停止等待ARQ

如果A发送的过程中出现差错，B在接收M1时检测出了差错，就丢弃M1，其他什么都不做（也不会通知A收到有差错的分组）。又或者A传送的过程中分组丢失了，以上这两种情况下，B不会发送任何信息。 



#### 发送丢失

如果发生以上的情况，A只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，所以它会重传刚刚的发送过的分组，也就是所谓的超时重传。 

![image-20210313180840886](https://gitee.com/Vanni/pic-bed/raw/master/img/image-20210313180840886.png)

1. 既然发送方发送的分组可能丢失或者有差错，可能需要重传，那么它必须暂时保留已发送的分组副本，只有收到确认后，才清除这个副本。

2. 分组和确认分组信息都应该有各自的编号，用来标示每一个分组和确认信息。（这样才知道需要发送哪个分组，收到了哪个分组的确认信息）

3. 超时计时器设置的时间应该略长于分组传送往返时间。

#### 确认丢失

如果A发送了M1分组，到达B，B发送了M1确认信息，但由于网络原因，该确认信息丢失。那么这个时候，A在超时重传时间内，没有收到B的确认信息，而且它并不知道是自己的分组有差错、丢失，还是B发生的确认丢失了。因此，A会在超时重传过后，重传M1分组。 

此时接收方B会有两个动作

- 丢弃M1分组，不向上级交付
- 向A发送确认

![image-20210313181233647](https://gitee.com/Vanni/pic-bed/raw/master/img/image-20210313181233647.png)

#### 确认延迟

![image-20210313181254413](https://gitee.com/Vanni/pic-bed/raw/master/img/image-20210313181254413.png)

停止等待协议中，每接收一个信息都会立刻响应，而发送方在接收到确认后才会接着发送下一个信息，这样的交互方式使得信道利用率低下



### 连续ARQ协议

![image-20210313181619264](https://gitee.com/Vanni/pic-bed/raw/master/img/image-20210313181619264.png)

发送方采用流水线传输。流水线传输就是发送方可以连续发送多个分组，不必每发完一个分组就停下来等待对方确认



当然所谓连续发送也不是无限的发送，需要发送方与接收方维护一个窗口

![image-20210313182148051](https://gitee.com/Vanni/pic-bed/raw/master/img/image-20210313182148051.png)



图（a）是发送方维持的发送窗口，它的意义是：位于发送窗口内的5个分组都可以连续发送出去，而不需要等待对方的确认，这样就提高了信道利用率。 

连续ARQ协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。例如上面的图（b），当发送方收到第一个分组的确认，就把发送窗口向前移动一个分组的位置。如果原来已经发送了前5个分组，则现在可以发送窗口内的第6个分组。 

接收方一般都是采用**累积确认**的方式。也就是说接收方不必对收到的分组逐个发送确认。而是在收到几个分组后，**对按序到达**的最后一个分组发送确认。如果收到了这个分组确认信息，则表示到这个分组为止的所有分组都已经正确接收到了。 

缺点是，不能正确的向发送方反映出接收方已经正确收到的所有分组的信息。比如发送方发送了前5个分组，而中间的第3个分组丢失了，这时候接收方只能对前2个发出确认。而不知道后面3个分组的下落，因此只能把后面的3个分组都重传一次，这种机制叫Go-back-N（回退N），表示需要再退回来重传已发送过的N个分组。




### 滑动窗口协议

滑动窗口协议在在发送方和接收方之间各自维持一个滑动窗口，发送方是发送窗口，接收方是接收窗口，而且这个窗口是随着时间变化可以向前滑动的。它允许发送方发送多个分组而不需等待确认。TCP的**滑动窗口是以字节为单位**的。

![image-20210313183242841](https://gitee.com/Vanni/pic-bed/raw/master/img/image-20210313183242841.png)

发送窗口（CWND）

- 已发送并收到确认的数据（不在发送窗口和发送缓冲区之内）
- 已发送但未收到确认的数据（位于发送窗口之内）
- 允许发送但尚未发送的数据（位于发送窗口之内）
- 发送窗口之外的缓冲区内暂时不允许发送的数据。



接收窗口（RWND）

- 已发送确认并交付主机的数据（不在接收窗口和接收缓冲区之内）
- 未按序收到的数据（位于接收窗口之内）
- 允许的数据（位于接收窗口之内）
- 不允许接收的数据（位于发送窗口之内）。



凡是已经发送过的数据，在未收到确认之前，都必须暂时保留，以便在超时重传时使用。

（2）只有当发送方A收到了接收方的确认报文段时，发送方窗口才可以向前滑动几个序号。

（3）当发送方A发送的数据经过一段时间没有收到确认（由超时计时器控制），就要使用回退N步协议，回到最后接收到确认号的地方，重新发送这部分数据。

![image-20210313183613581](https://gitee.com/Vanni/pic-bed/raw/master/img/image-20210313183613581.png)



为了解决流水线传输的差错，TCP协议提供**两种滑动窗口**：**回退N(Go-Back- N，GBN)** 和**选择重传(Selective Repeat，SR)** 来解决这个问题



#### 回退N帧

如果发送方发送了前5个分组，而中间的第三个分组丢失了。这是接收方只能对前两个分组发出确认。

发送方无法知道后面三个分组的下落，只好把后面的三个分组都重传一次

当通信线路质量不好的时候，连续ARQ协议就会带来负面的影响，如果网络层协议（ L3）丢失了很多分组，那么这个回退N帧的协议就会变得很低效

![image-20220816204106547](https://raw.githubusercontent.com/VanniAmor/ImgBed/master/image-20220816204106547.png)

#### 选择重传

选择重传协议只重传真正出错或者丢失的帧。

![在这里插入图片描述](https://raw.githubusercontent.com/VanniAmor/ImgBed/master/4f4609a12ae44c0f951502d9fc11fc1e.png)



1. 发送方维持一个窗口，包含可发送或已发送但未确认的序号
2. 接收方维持着一个窗口，包含可接收的序号，每个序号还保留一个缓冲区。与每个缓冲区项相关联的还有一个标志位，用来指明缓冲区是满的还是空的。

![在这里插入图片描述](https://raw.githubusercontent.com/VanniAmor/ImgBed/master/5223917730374e379508433065883042.png)

3. 每到达一个帧，接收方通过检查它的序号，看是否落在窗口内。如果确实落在窗口内且之前没有接收过，则接收该分组然后保存在缓冲区并返回一个确认。等前面这些帧都到达后一起交付给上层协议
4. 发送端每个发送缓冲都设有一个超时计时器，一个超时事件发生后相应缓冲区的帧就会被重发

![image-20220816205631695](https://raw.githubusercontent.com/VanniAmor/ImgBed/master/image-20220816205631695.png)

![image-20220816205705028](https://raw.githubusercontent.com/VanniAmor/ImgBed/master/image-20220816205705028.png)

这个问题，通常通过设置窗口大小来解决

1. 让接收窗口大小等于发送窗口
2. 发送窗口=接收窗口=2^(n-1)，n表示用多少bit来表示允许发送的帧序号，上文发送了8个帧（2^3），即3bit，所以窗口大小应小于等于2^(3-1) = 4

![image-20220816210020019](https://raw.githubusercontent.com/VanniAmor/ImgBed/master/image-20220816210020019.png)

### ARQ运行在哪一层

> 1. ARQ是一种可以在不可靠的数据通道上可靠地传输数据的方案，所以其实链路层和传输层都用了ARQ，并不专属某一层。
> 2. 并不是一条连接只要有一层用了ARQ，它的上层的通信就是可靠的。因为ARQ只保证使用它的点到点是可靠的，比如数据链路层只保证你和你的路由器通信可靠，你的路由器到小区的路由器通信也可靠， 但是路由器本身会故障，会拥塞丢包，也就是点本身会产生问题。
> 3. 所以需要在传输层或者应用层再加一层ARQ保障整条数据通道的可靠性。比如你自己写程序要在应用层通信，但传输层不用tcp想用udp，也可以在你程序里用ARQ协来实现可靠性。



## 校验和



TCP通过三个简单的工具来完成其差错控制：检验和、确认以及超时。



TCP校验和（Checksum）是一个端到端的校验和，由发送端计算，然后由接收端验证。其目的是为了发现TCP首部和数据在发送端到接收端之间发生的任何改动。如果接收方检测到校验和有差错，则TCP段会被直接丢弃。



TCP校验和**覆盖TCP首部和TCP数据**，而IP首部中的校验和只覆盖IP的首部，不覆盖IP数据报中的任何数据。TCP校验和、IP校验和的计算方法是基本一致的，除了计算的范围不同。



**TCP的校验和是必需的，而UDP的校验和是可选的**，每个tcp报文计算校验和的时候，都要加上一个12字节的伪首部



![image-20210317224318635](https://gitee.com/Vanni/pic-bed/raw/master/img/image-20210317224318635.png)



首先解释下伪首部的概念，伪首部的数据都是从IP数据报头获取的。其目的是让TCP检查数据是否已经正确到达目的地，只是单纯为了做校验用的。



伪首部共有12字节（前96Bits），包含如下信息：源IP地址、目的IP地址、保留字节(置0)、传输层协议号(TCP是6)、TCP报文长度(报头+数据)。



伪首部是为了增加TCP校验和的检错能力：如检查TCP报文是否收错了(目的IP地址)、传输层协议是否选对了(传输层协议号)等。



首先，把伪首部、TCP报头、TCP数据分为16位的字，如果总长度为奇数个字节，则在最后增添一个位都为0的字节。把TCP报头中的校验和字段置为0（否则就陷入鸡生蛋还是蛋生鸡的问题）。
其次，用反码相加法累加所有的16位字（进位也要累加）。
最后，对计算结果取反，作为TCP的校验和。



1、首先将检验和置零；
2、然后将TCP伪首部部分，TCP首部部分，数据部分都划分成16位的一个个16进制数
3、将这些数逐个相加，记得**溢出的部分加到最低位上**，这是循环加法：
 0xc0a8+ 0x0166+……+0x0402=0x9b49
4、最后将得到的结果取反，则可以得到检验和位0x64b6



## 参考文献

https://blog.csdn.net/qq_38289815/article/details/100176632

https://blog.csdn.net/qq_33314107/article/details/81607630

https://blog.csdn.net/a_tu_/article/details/84840592

https://www.cnblogs.com/zxiner/p/7203192.html