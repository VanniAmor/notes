## KeepAlive的初衷

当应用采用C/S模式，且为长链接时，若连接双方在连接空闲状态时，如果任意一方意外崩溃、宕机、重启、网线断开等，另一方是无法得知TCP已经失效的。

这样就会造成很多半打开链接的积累，耗费系统资源

KeepAlive就是为了解决这个问题的TCP连接保活机制



## 从NAT的角度来理解KeepAlive的必要性



NAT协议，又分为SNAT（原地址转换）和DNAT（目标地址转换），**NAT协议工作在传输层**，其作用就是网络地址转换，即公网IP地址与局域网IP地址的相互转换



### 三层地址转换

局域网内的主机向公网发出的网络层IP报文，将经由网关被转发至公网，在转换过程中发生了网络地址转换。网关将该IP报文中的 源IP地址 从 “该主机的内网IP” 修改为 “网关的公网IP”



**需要注意的是**，如果这个IP报文的数据段不含传输层协议报文，而是一个pure的网络层packet，来自目标主机的响应报文是不能被网关准确转发到多台局域网主机中的一台的



### 传输层端口转换



在三层地址转换中，我们可以保证局域网内向公网发出的IP报文能顺利到达目的主机，但是从目的主机返回的报文却不能准确送至指定的局域网主机（我们不能在网关把IP报文进行全局域网主机广播，这样做并不安全）

为了解决这个问题，需要借助传输层端口，通常是TCP或UDP端口，由此来生成一张端口转换表

[![gPDLaF.png](https://z3.ax1x.com/2021/04/28/gPDLaF.png)](https://imgtu.com/i/gPDLaF)

假设局域网主机A 192.168.1.100需要向公网上的主机210.199.38.2进行一次TCP的通信，其中A局域网的公网地址为210.177.63.2

步骤如下

1. 局域网主机A192.168.1.100发出TCP请求，A上的TCP端口为系统分配的53600，该握手包中，包含源地址和端口地址 192.168.1.100:56300，和目的地址210.199.38.2:80

2. 网关C将包的原地址替换为A局域网的公网地址
3. 网关C向端口转换表中增加一条记录
4. 网关C将修改后的TCP包发送至目的主机B
5. 目的主机收到后，作出响应，源地址和端口 210.199.38.2:80， 目的地址和端口210.177.63.2:53600
6. 网关C接受到响应包，并搜索端口转换表，找到其对应的内网主机
7. 网关C修改响应包的目的地址和端口
8. 网关C将修改后的包转发给内网中的主机A



在这个通讯过程中，网关的端口是有限的，而端口转换表的存储和转发，由于网关的处理速度和存储空间等问题，不可能过大。所以对于过期的记录，需要进行删除



那么如何判断TCP的链接过期呢

[![gP6HSJ.png](https://z3.ax1x.com/2021/04/28/gP6HSJ.png)](https://imgtu.com/i/gP6HSJ)



当长时间无数据交互时，网关会把端口转换表中的数据删除，但是此时，服务端和客户端均是无感的。



那么当业务需要进行长时间的连接时（但又不能保证连接过程中时刻都发送数据的传输），如何让网关认为TCP的连接是活动的，避免网关删除端口转化表的记录呢



从TCP的协议层来说，这个方法就是KeepAlive机制



## keepalive的实现

当一个TCP链接建立后，启用tcp keepalive的一端就会启动一个计时器，当这个计时器的数值到达0之后（即 经过` tcp_keep_alive_time`时间后），一个tcp探测包会被发出。这个TCP探测包是一个纯粹的ACK包（不包含任何数据或包含一个没有意义的字节，如0x0），其seq号与上一个包是重复的，所以其实探测保活报文不在窗口的控制范围内。

如果一个给定的连接在两个小时内（默认时长）没有任何动作，则服务端向客户端发送一个探测报文，客户端主机必须处于以下四个状态之一。

![image-20210427101324561](https://raw.githubusercontent.com/VanniAmor/ImgBed/master/image-20210427101324561.png)

- 客户主机仍在运行且可达。客户端的TCP响应正常，而服务端也知道对方是正常的，服务端重置保活计时器
- 客户端主机崩溃（关闭或正在重启）。在这任一情况下，客户端的TCP都没有响应。服务端将不能接收到对探测的响应，并在75秒后超时。服务端将发送10探测包，每个间隔75秒，若服务端没有收到一个响应，就认为客户端主机已经关闭，此时服务端关闭连接。
- 客户端崩溃并已经完成重启，服务端将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接
- 客户机正常运行，但服务器不可达，进行每75秒一次的重试，达到最大重试次数后，断开连接

交互示意图如下：

![image-20210427102100196](https://raw.githubusercontent.com/VanniAmor/ImgBed/master/image-20210427102100196.png)

### 重要配置参数

以linux内核为例，应用程序若想使用TCP KeepAlive，需要设置SO_KEEPALIVE套接字选项才能生效

- tcp_keepalive_time，TCP允许的持续空闲时长，默认7200s，每次正常发送心跳的周期
- tcp_keepalive_probes，在tcp_keepalive_time之后，没有接收到对方确认，继续发送探测包的次数，默认为9
- tcp_keepalive_intvl，在tcp_keepalive_time后，没有接收到对方确认，继续发送保活探测包的发送频率，默认为75s



## 可能造成的问题

**默认情况下，keepalive机制是**

- 在短暂的故障期间，keepalive设置不合理时可能会因为短暂的网络波动而断开健康的TCP链接

- 需要消耗额外的宽带和流量

- 在以流量计费的互联网环境增加了费用

  

## 局限性

既然TCP已经有KeepAlive机制，那为何需要在应用层实现保活/心跳机制呢

- 运营商ISP网络资源紧缺，TCP协议默认2小时的KeepAlive基本不可能实现IM的长链接（过于浪费），为了提升无线网络的利用率，运营商长则几分钟，短则数十秒就会回收空闲的链接
- 无线网络本身存在弱网问题，即使TCP链接是好的，但实际上是处于“假死”状态，无法起到长链接应该有的作用



## TCP KeepAlive 与 HTTP Keep-Alive

从HTTP/1.1起，默认使用长连接，用以保持连接。

其作用也很明显，如下

![image-20210427105954808](https://raw.githubusercontent.com/VanniAmor/ImgBed/master/image-20210427105954808.png)

- HTTP的Keep-Alive是为了让TCP连接活得久一点，在发起多个http连接的时候，可以复用同一个TCP连接，提高通信效率
- TCP的KeepAlive意图是探测连接是否存活，是一种检测连接

