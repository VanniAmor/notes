## 概述

TCP是面向连接的可靠传输协议，是以流作为传输方式的

所谓流，是指字节流，是指流入到进程或从进程流出的字节序列。

虽然应用程序和TCP的交互是一次一个数据块，但TCP把应用程序交下来的数据看成是一连串无结构的字节流。



所谓可靠，即保证通信过程中消息的**完整，正确，有序**



而TCP协议是利用滑动窗口协议和ARQ协议，配合流量控制和拥塞控制，来实现可靠传输



## 滑动窗口与连续ARQ协议

通过ARQ和滑动窗口来保证数据的正确性



### ARQ协议

ARQ协议，即自动重传请求（Automatic Repeat-Request），若果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括**停止等待ARQ协议和连续ARQ协议**，拥有错误检测（Error Detection）、正面确认（Positive Acknowledgment）、超时重传（Retransmission after Timeout）和 负面确认及重传（Negative Acknowledgment and Retransmission）等机制。


### 停止等待ARQ

如果A发送的过程中出现差错，B在接收M1时检测出了差错，就丢弃M1，其他什么都不做（也不会通知A收到有差错的分组）。又或者A传送的过程中分组丢失了，以上这两种情况下，B不会发送任何信息。 



#### 发送丢失

如果发生以上的情况，A只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，所以它会重传刚刚的发送过的分组，也就是所谓的超时重传。 

![image-20210313180840886](https://gitee.com/Vanni/pic-bed/raw/master/img/image-20210313180840886.png)

1. 既然发送方发送的分组可能丢失或者有差错，可能需要重传，那么它必须暂时保留已发送的分组副本，只有收到确认后，才清除这个副本。

2. 分组和确认分组信息都应该有各自的编号，用来标示每一个分组和确认信息。（这样才知道需要发送哪个分组，收到了哪个分组的确认信息）

3. 超时计时器设置的时间应该略长于分组传送往返时间。
   

#### 确认丢失

如果A发送了M1分组，到达B，B发送了M1确认信息，但由于网络原因，该确认信息丢失。那么这个时候，A在超时重传时间内，没有收到B的确认信息，而且它并不知道是自己的分组有差错、丢失，还是B发生的确认丢失了。因此，A会在超时重传过后，重传M1分组。 

此时接收方B会有两个动作

- 丢弃M1分组，不向上级交付
- 向A发送确认

![image-20210313181233647](https://gitee.com/Vanni/pic-bed/raw/master/img/image-20210313181233647.png)

#### 确认延迟

![image-20210313181254413](https://gitee.com/Vanni/pic-bed/raw/master/img/image-20210313181254413.png)

停止等待协议中，每接收一个信息都会立刻响应，而发送方在接收到确认后才会接着发送下一个信息，这样的交互方式使得信道利用率低下



### 连续ARQ协议

![image-20210313181619264](https://gitee.com/Vanni/pic-bed/raw/master/img/image-20210313181619264.png)

发送方采用流水线传输。流水线传输就是发送方可以连续发送多个分组，不必每发完一个分组就停下来等待对方确认



当然所谓连续发送也不是无限的发送，需要发送方与接收方维护一个窗口

![image-20210313182148051](https://gitee.com/Vanni/pic-bed/raw/master/img/image-20210313182148051.png)



图（a）是发送方维持的发送窗口，它的意义是：位于发送窗口内的5个分组都可以连续发送出去，而不需要等待对方的确认，这样就提高了信道利用率。 

连续ARQ协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。例如上面的图（b），当发送方收到第一个分组的确认，就把发送窗口向前移动一个分组的位置。如果原来已经发送了前5个分组，则现在可以发送窗口内的第6个分组。 

接收方一般都是采用**累积确认**的方式。也就是说接收方不必对收到的分组逐个发送确认。而是在收到几个分组后，对按序到达的最后一个分组发送确认。如果收到了这个分组确认信息，则表示到这个分组为止的所有分组都已经正确接收到了。 

缺点是，不能正确的向发送方反映出接收方已经正确收到的所以分组的信息。比如发送方发送了前5个分组，而中间的第3个分组丢失了，这时候接收方只能对前2个发出确认。而不知道后面3个分组的下落，因此只能把后面的3个分组都重传一次，这种机制叫Go-back-N（回退N），表示需要再退回来重传已发送过的N个分组。


### 滑动窗口协议

滑动窗口协议在在发送方和接收方之间各自维持一个滑动窗口，发送发是发送窗口，接收方是接收窗口，而且这个窗口是随着时间变化可以向前滑动的。它允许发送方发送多个分组而不需等待确认。TCP的**滑动窗口是以字节为单位**的。

![image-20210313183242841](https://gitee.com/Vanni/pic-bed/raw/master/img/image-20210313183242841.png)

- 已发送并收到确认的数据（不在发送窗口和发送缓冲区之内）
- 已发送但未收到确认的数据（位于发送窗口之内）
- 允许发送但尚未发送的数据（位于发送窗口之内）
- 发送窗口之外的缓冲区内暂时不允许发送的数据。



- 已发送确认并交付主机的数据（不在接收窗口和接收缓冲区之内）
- 未按序收到的数据（位于接收窗口之内）
- 允许的数据（位于接收窗口之内）
- 不允许接收的数据（位于发送窗口之内）。



凡是已经发送过的数据，在未收到确认之前，都必须暂时保留，以便在超时重传时使用。

（2）只有当发送方A收到了接收方的确认报文段时，发送方窗口才可以向前滑动几个序号。

（3）当发送方A发送的数据经过一段时间没有收到确认（由超时计时器控制），就要使用回退N步协议，回到最后接收到确认号的地方，重新发送这部分数据。

![image-20210313183613581](https://gitee.com/Vanni/pic-bed/raw/master/img/image-20210313183613581.png)



## 流量控制

TCP 提供了流量控制服务以消除发送方使接收方缓存区溢出的可能性，因此 **TCP 流量控制是为了匹配发送方的发送速率与接收方的读取速率**。

TCP中使用滑动窗口机制来实现流量控制

![image-20210313183911206](https://gitee.com/Vanni/pic-bed/raw/master/img/image-20210313183911206.png)



## 拥塞控制



**拥塞控制是让网络能够承受现有的网络负荷，它是一个全局性的过程，涉及所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。**而流量控制往往使指点对点通信量的控制，即接收端控制发送端，它所做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。

- 慢开始

- 拥塞避免

- 快重传

- 快恢复

  

![image-20210313183735190](https://gitee.com/Vanni/pic-bed/raw/master/img/image-20210313183735190.png)



## 差错校验



TCP校验和（Checksum）是一个端到端的校验和，由发送端计算，然后由接收端验证。其目的是为了发现TCP首部和数据在发送端到接收端之间发生的任何改动。如果接收方检测到校验和有差错，则TCP段会被直接丢弃。



TCP校验和**覆盖TCP首部和TCP数据**，而IP首部中的校验和只覆盖IP的首部，不覆盖IP数据报中的任何数据。TCP校验和、IP校验和的计算方法是基本一致的，除了计算的范围不同。



**TCP的校验和是必需的，而UDP的校验和是可选的**，每个tcp报文计算校验和的时候，都要加上一个12字节的伪首部



![image-20210317224318635](https://gitee.com/Vanni/pic-bed/raw/master/img/image-20210317224318635.png)



首先解释下伪首部的概念，伪首部的数据都是从IP数据报头获取的。其目的是让TCP检查数据是否已经正确到达目的地，只是单纯为了做校验用的。



伪首部共有12字节（前96Bits），包含如下信息：源IP地址、目的IP地址、保留字节(置0)、传输层协议号(TCP是6)、TCP报文长度(报头+数据)。



伪首部是为了增加TCP校验和的检错能力：如检查TCP报文是否收错了(目的IP地址)、传输层协议是否选对了(传输层协议号)等。



首先，把伪首部、TCP报头、TCP数据分为16位的字，如果总长度为奇数个字节，则在最后增添一个位都为0的字节。把TCP报头中的校验和字段置为0（否则就陷入鸡生蛋还是蛋生鸡的问题）。
其次，用反码相加法累加所有的16位字（进位也要累加）。
最后，对计算结果取反，作为TCP的校验和。



1、首先将检验和置零；
2、然后将TCP伪首部部分，TCP首部部分，数据部分都划分成16位的一个个16进制数
3、将这些数逐个相加，记得**溢出的部分加到最低位上**，这是循环加法：
 0xc0a8+ 0x0166+……+0x0402=0x9b49
4、最后将得到的结果取反，则可以得到检验和位0x64b6



## 参考文献

https://blog.csdn.net/qq_38289815/article/details/100176632

https://blog.csdn.net/qq_33314107/article/details/81607630

https://blog.csdn.net/a_tu_/article/details/84840592